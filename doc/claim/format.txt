This Text Character is EUC-JP Code.

CLAIM通信スクリプト version2.0 設定ファイル形式 ドキュメント
                                             日医標準レセプトソフト開発チーム



-----------------------------------------------------------------------------
概要

CLAIM通信スクリプトは、設定ファイルを修正することで、XMLファイルとシーケンシャルファイルの設定を変更することができる。
そのため、シーケンシャルファイルのフォーマットが変わることで、スクリプト本体の修正が発生することはない。

このドキュメントでは、設定ソースファイルについて解説する。



-----------------------------------------------------------------------------
詳細

設定ファイルには、以下のようなファイルがある。

★defファイル
  送信時に使用する設定ファイル。
  templateファイルのパラメータにセットする内容が、シーケンシャルファイルのどこにあるかを定義するファイルである。

★templateファイル
  送信時に使用する設定ファイル。
  送信するXMLファイルの元となるファイルである。
  %〜%でくくられたパラメータに対して、シーケンシャルファイルの内容をセットしてから、電子カルテへXMLファイルを送信する。

★階層データファイル
  受信時に使用する設定ファイル。
  XMLパスに近い形の階層定義とバイト数を設定するようになっている。
  該当する階層の内容を先頭から定義されたバイト数の領域に対して格納する。未定義の階層定義については、空白にする。


設定ファイルの格納ディレクトリ、および、実行時に使う設定ファイルへのコンバート方法は、「convert.txt」を参照すること。



-----------------------------------------------------------------------------
defファイル


----------------------------------------
コメント


☆概要
説明・コメントを記述する。


☆書式
# [コメント]


☆備考
行の先頭に記述すること。
定義の後ろにコメントを書くことはしないこと。



----------------------------------------
識別情報定義


☆概要
コンバート等での互換性を確保できるようにすることを考えて設けた定義。
必ず一行目に書くこと。


☆書式
#$ type=[figure-define | hierarchy] version=2.0 encoding=EUC-JP

  type=figure-define  : defファイルの定義
  type=hierarchy      : 階層情報の定義

  version=2.0         : バージョン情報(今回のバージョンは2.0とする)

  encoding=EUC-JP     : 現在は、EUC-JPで固定


☆備考
上記の記述は、version2.0の記述である。
実行時に使用する設定ファイルでも、上記に似た形式を持つ。現在の実行時用のtype定義は「type=[figure-define-execute | hierarchy-execute]」となる。ただし、version1.0の実行時の形式は除く。(2004年1月現在)



----------------------------------------
$const定義


☆概要
「$const」定義は、シーケンシャルファイルでセットしないが、テンプレートファイルのパラメータへセットしたい内容を定義するためのものである。


☆書式
$const, [%パラメータ名%], [内容]


☆備考
デバッグ用途での利用を考えて用意した。
「$ifdef」〜「$endif」構文において、特定のパラメータの定義がない場合に、単独タグを削除する等にも使用できる。


☆例

例1) %ACC1%のパラメータに「<accessRight permit="all" />」の内容をセットする
--------------------
# アクセス権定義
$const, %ACC1%, <accessRight permit="all" />
--------------------



----------------------------------------
$nowdate定義


☆
「$nowdate」定義は、XMLファイルを生成するときの時刻を、パラメータにセットするものである。


☆書式
$nowdate, [%パラメータ名%], [strftimeメソッドの引数に指定するフォーマット]


☆備考
時刻フォーマットについては、以下のパラメータを指定する。
   %c - 日付と時刻
   %x - 日付
   %X - 時刻
   %Y - 西暦
   %y - 西暦の下２桁(00-99)
   %m - 月(01-12)
   %d - 日 (01-31)
   %A - 曜日の名称 (Sunday, Monday...)
   %a - 曜日の省略名 (Sun, Mon...)
   %w - 曜日を表す数字 (0-6) (0 = 日曜日)
   %p - 午前、または、午後 (AM, PM)
   %H - 24時間制の時 (00-23)
   %I - 12時間制の時 (01-12)
   %M - 分 (00-59)
   %S - 秒 (00-60)
   %% - 文字の%
MMLのdateTime型は「%Y-%m-%dT%H:%M:%S」、date型は「%Y-%m-%d」,time型は「%H:%M:%S」である。
version1.0では、「%Y-%m-%dT%H:%M:%S」のみ指定できる。それ以外は指定できない。


☆例

例1) %CREATEDATE%のパラメータに、MMLのdateTime型で現在の日時をセットする
--------------------
# 作成日時のセット
$nowdate, %CREATEDATE%, %Y-%m-%dT%H:%M:%S
--------------------



----------------------------------------
$ifdef〜$endif定義


☆概要
「$ifdef」定義は、引数で指定されたパラメータに値が入っていない場合に、「$endif」までの定義を無効にするためのものである。
これにより、ボディ部分が定義していない場合に、ヘッダの定義も無効にするということが可能になる。（$const定義も、この部分については、デバッグ以外での用途に使える）


☆書式
$ifdef, [and または or], %〜%<, %〜%<, %〜%>>
   〜
$endif


☆備考



☆例

例1) パラメータ「%A01%」か「%B01%」のいずれかに値が入っていれば、$ifdef〜$endifの間にある「%N01%」「%N02%」のパラメータを有効にする。
--------------------
# 判定
$ifdef, or, %A01%, %B01%
    %N01%, 10
    %N02%, 5
$endif
--------------------
「%A01%」「%B01%」のいずれかに値が入っている場合は、以下のようになる
--------------------
# 判定
    %N01%, 10
    %N02%, 5
--------------------
「%A01%」「%B01%」とも空白の場合は、以下のように「%N01%」「%N02%」の定義自体がなくなる
--------------------
# 判定
--------------------



----------------------------------------
$Repeat定義


☆概要
$Repeatの行から$EndRepeatまでを、指定された回数繰り返す。
その際に、引数で指定された文字列を数字に変換する。


☆書式
$Repeat, [繰り返し回数], [置換対象文字列], [桁数指定(0の場合、自由桁数)]
$EndRepeat


☆例

例1) 「$Repeat」〜「$EndRepeat」を「5」回繰り返す。その繰り返した中に「@@CNT1@@」があれば、その間を１オリジンの（１から始まる）数字「2」桁に変換する。
--------------------
$Repeat, 5, @@CNT1@@, 2
    %a01-@@CNT1@@%, 10
    %a02-@@CNT1@@%, 5
$EndRepeat
--------------------
    ↓変換後
--------------------
    %a01-01%, 10
    %a02-01%, 5
    %a01-02%, 10
    %a02-02%, 5
    %a01-03%, 10
    %a02-03%, 5
    %a01-04%, 10
    %a02-04%, 5
    %a01-05%, 10
    %a02-05%, 5
--------------------



----------------------------------------
通常のパラメータセット


☆概要
タグやエレメントのテキスト（開始タグと終了タグの間にある内容）をセットする際に指定する。


☆書式
[%パラメータ名%], [バイト数]


☆例

例1) 先頭から、パラメータ名「%DIG_NAME%」に40バイト、「%DIG_DIAGNOSIS%」に50バイトの領域を定義
--------------------
%DIG_NAME%,      40
%DIG_DIAGNOSIS%, 50
--------------------



----------------------------------------
属性のパラメータセット


☆概要
タグの属性に設定するパラメータのバイト数を指定する。


☆書式
[%パラメータ名%], [バイト数], [属性名]


☆備考
タグにセットする際に、前側への空白と属性名をセットするように、実行時に処理される。これにより、該当する属性に情報がない場合に、空白をセットすることで、該当する属性自体が存在しないようにできる。


☆例

例1) 属性名「lang」に定義するパラメータ名「%DIG_LANG%」に10バイトの領域を定義
--------------------
%DIG_LANG%, 10, lang
--------------------



----------------------------------------



-----------------------------------------------------------------------------
templateファイル

templateファイルは、XMLファイルの元ファイルとなる。
defファイルと関係があり、defファイルで定義したパラメータ名がtemplateファイルにも記述してあり、defファイルで定義した位置の内容が、templateファイルのパラメータの場所にセットされる。これを繰り返すことで、XMLファイルが作成される。
XMLファイル生成の際、最終的に空白のタグは削除されるようなロジックが組まれている。そのため、余分な指定があっても、最終的に出力されるXMLファイルはコンパクトになるようにしてある。(2004年1月現在)

パラメータ名は「%〜%」という名前で定義する。


----------------------------------------
$Repeat定義


☆概要
$Repeatの行から$EndRepeatまでを、指定された回数繰り返す。
その際に、引数で指定された文字列を数字に変換する。（変換したくない場合は、適当な文字列を割り当てる）


☆書式
$Repeat, [繰り返し回数], [置換対象文字列], [桁数指定(0の場合、自由桁数)]
$EndRepeat


☆例

例1) 「$Repeat」〜「$EndRepeat」を「3」回繰り返す。その繰り返した中に「@@COUNT@@」があれば、その間を１オリジンの（１から始まる）数字「3」桁に変換する。
--------------------
$Repeat, 3, @@COUNT@@, 3
    <book num="@@COUNT@@">
        <date>
            %BOOK_DATE_@@COUNT@@%
        </date>
        <memo>
            %BOOK_MEMO_@@COUNT@@%
        </memo>
    </book>
$EndRepeat
--------------------
    ↓変換後
--------------------
    <book num="001">
        <date>
            %BOOK_DATE_001%
        </date>
        <memo>
            %BOOK_MEMO_001%
        </memo>
    </book>
    <book num="002">
        <date>
            %BOOK_DATE_002%
        </date>
        <memo>
            %BOOK_MEMO_002%
        </memo>
    </book>
    <book num="003">
        <date>
            %BOOK_DATE_003%
        </date>
        <memo>
            %BOOK_MEMO_003%
        </memo>
    </book>
--------------------



----------------------------------------



-----------------------------------------------------------------------------
階層データファイル

階層データファイルは、記述された階層の内容をシーケンシャルファイルのどの位置に格納するかを記述するファイルである。
階層の記述方法は、XMLパスに似た形をとる。

以下のようなXMLがあるとする。
--------------------
<a>
    <b>
        あ
    </b>
    <c>
        <d num="1">
            Ａ
        </d>
        <d num="2">
            Ｂ
        </d>
    </c>
</a>
--------------------
この場合、「あ」のある階層は「/a[1]/b[1]」と記述する。そして、「Ａ」のある階層は「/a[1]/c[1]/d[1]」と記述する。
見ると、タグの名前の後ろに[1]という記述を加えているが、これは同じタグの名前が複数あることを考えてのことである。
たとえば、「Ａ」のある<d>〜<d>タグは、同じ<c>〜</c>の中に複数存在している。そのため、何番目のタグかを記述する配列のような意味をとる。（配列は１オリジンで記述する）
「Ａ」のタグの記述は「/a[1]/c[1]/d[1]」となり、「Ｂ」のタグの記述は「/a[1]/c[1]/d[2]」となる。「Ｂ」のある「d」タグは２番目なので、配列は「2」となる。
属性の記述は、属性の名前の前に「@」を加えた形をとる。属性は、同じタグの中に複数存在しないことを前提にしているので、配列の記述はしない。
「1」がセットされている<d>タグの配列「num」の記述は、「/a[1]/c[1]/d[1]@num」となる。
「2」がセットされている<d>タグの配列「num」の記述は、「/a[1]/c[1]/d[2]@num」となる。

上記をまとめると、以下のような階層データファイルができあがる。
--------------------
/a[1]/b[1]=10
/a[1]/c[1]/d[1]=20
/a[1]/c[1]/d[1]@num=6
/a[1]/c[1]/d[2]=20
/a[1]/c[1]/d[2]@num=6
--------------------
左辺に階層を記述し、「=」を挟んで、右辺に該当する内容のバイト数を記述する。
XMLからシーケンシャルファイルに変換するスクリプトは、先頭から指定されたバイト数をセットしていく。記述されたタグが存在しなかった場合は、スクリプト側で指定された箇所を空白で埋める。

上記で示したXMLファイルと階層データファイルを使って、シーケンシャルファイルに変換すると、以下のようなシーケンシャルファイルが作成される。
--------------------
+---------+-------------------+-----+-------------------+-----
あ        Ａ                  1     Ｂ                  2     
--------------------



----------------------------------------
識別情報定義


☆概要
コンバート等での互換性を確保できるようにすることを考えて設けた定義。
必ず一行目に書くこと。


☆書式
#$ type=[figure-define | hierarchy] version=2.0 encoding=EUC-JP

  type=figure-define  : defファイルの定義
  type=hierarchy      : 階層情報の定義

  version=2.0         : バージョン情報(今回のバージョンは2.0とします)

  encoding=EUC-JP     : 現在は、EUC-JPで固定


☆備考
上記の記述は、version2.0の記述である。
実行時に使用する設定ファイルでも、上記に似た形式を持つ。現在の実行時用のtype定義は「type=[figure-define-execute | hierarchy-execute]」となる。ただし、version1.0の実行時の形式は除く。(2004年1月現在)



----------------------------------------
$Repeat定義


☆概要
$Repeatの行から$EndRepeatまでを、指定された回数繰り返す。
その際に、引数で指定された文字列を数字に変換する。（変換したくない場合は、適当な文字列を割り当てる）


☆書式
$Repeat, [繰り返し回数], [置換対象文字列], [桁数指定(0の場合、自由桁数)]
$EndRepeat


☆例

例1) 「$Repeat」〜「$EndRepeat」を「10」回繰り返す。その繰り返した中に「@@CNT@@」があれば、その間を１オリジンの（１から始まる）前０なしの数字に変換する。
--------------------
$Repeat, 10, @@CNT@@, 0
    /body[1]/book[@@CNT@@]@num=5
    /body[1]/book[@@CNT@@]/date[1]=10
    /body[1]/book[@@CNT@@]/memo[1]=50
$EndRepeat
--------------------
    ↓変換後
--------------------
    /body[1]/book[1]@num=5
    /body[1]/book[1]/date[1]=10
    /body[1]/book[1]/memo[1]=50
    /body[1]/book[2]@num=5
    /body[1]/book[2]/date[1]=10
    /body[1]/book[2]/memo[1]=50
    /body[1]/book[3]@num=5
    /body[1]/book[3]/date[1]=10
    /body[1]/book[3]/memo[1]=50
    /body[1]/book[4]@num=5
    /body[1]/book[4]/date[1]=10
    /body[1]/book[4]/memo[1]=50
    /body[1]/book[5]@num=5
    /body[1]/book[5]/date[1]=10
    /body[1]/book[5]/memo[1]=50
    /body[1]/book[6]@num=5
    /body[1]/book[6]/date[1]=10
    /body[1]/book[6]/memo[1]=50
    /body[1]/book[7]@num=5
    /body[1]/book[7]/date[1]=10
    /body[1]/book[7]/memo[1]=50
    /body[1]/book[8]@num=5
    /body[1]/book[8]/date[1]=10
    /body[1]/book[8]/memo[1]=50
    /body[1]/book[9]@num=5
    /body[1]/book[9]/date[1]=10
    /body[1]/book[9]/memo[1]=50
    /body[1]/book[10]@num=5
    /body[1]/book[10]/date[1]=10
    /body[1]/book[10]/memo[1]=50
--------------------



----------------------------------------
$BaseStart定義・$BaseEnd定義


☆概要
基準となる階層を定義する。


☆書式
$BaseStart, [ベース階層]
$BaseEnd


☆備考
この定義は、基準階層からの相対パスの指定を可能にすることで、記述するパスを少なくし、見やすさ・定義のしやすさをあげる目的で設けた。
$BaseStart〜$BaseEndの間であれば、XMLパスの指定方法として、相対パスの指定が可能になる。


☆例

例1) 基準ディレクトリを「/body[1]/book[1]」にする。
--------------------
$BaseStart, /body[1]/book[1]
    date[1]=10
$BaseEnd
--------------------
    ↓変換後
--------------------
    /body[1]/book[1]/date[1]=10
--------------------



----------------------------------------
$LineTargetStart定義・$LineTargetEnd定義


☆概要
配列指定なしのXMLパスが複数存在する場合に、シーケンシャルファイルへセットする際の配列番号を実行時に決定するための定義。
属性から該当するタグ配下の内容が大きく異なる場合に効果を発揮する。


☆書式
$LineTargetStart, [比較対象階層] = [内容], [１オリジンの開始位置], [置換対象階層]
$LineTargetEnd


☆備考
旧形式の「$LineTargetStart」には識別子が存在するが、新形式の「$LineTargetStart」と「$BaseStart」に識別子は設けない。
使いどころが難しい定義ではあるが、例を見て判断してもらいたい。


☆例

例1) 「/body[1]/book[X]/name[1]@atr」が「Dictionary」となっている２番目を対象にする。

基準ディレクトリを「/body[1]/book[1]」にする。
--------------------
$LineTargetStart, /body[1]/book[X]/name[1]@atr = Dictionary, 2, /body[1]/book[X]
    /body[1]/book[X]/name[1] = 30
    /body[1]/book[X]/date[1] = 10
    /body[1]/book[X]/memo[1] = 60
$LineTargetEnd
--------------------
たとえば、nameのatrが「Dictionary」「Magazine」「Comic」「Dictionary」という順番でXMLが渡ってきた場合、２番目のDictionaryは、全体のbookの中で４番目となる。その結果、変換後は以下のようになる。
--------------------
    /body[1]/book[4]/name[1] = 30
    /body[1]/book[4]/date[1] = 10
    /body[1]/book[4]/memo[1] = 60
--------------------



----------------------------------------
絶対階層情報


☆概要
XMLパスの書式に近い形で、階層情報を定義する。
先頭に「/」を付けることで、一番上からの階層を指定する。
タグ名の後ろには、必ず配列番号を指定し、複数のタグに対応できるようにする。
タグの属性の場合は「@」の後に、属性名を指定する。その際、属性に配列番号は指定しない。


☆書式
/<タグ名>[<配列番号>]/<タグ名>[<配列番号>] = <バイト数>
/<タグ名>[<配列番号>]/<タグ名>[<配列番号>]@<属性名> = <バイト数>


☆備考
配列番号は、[]括弧でくくること。（XMLPathの記述に似せるため）


☆例

例1)
--------------------
/body[1]/book[1]/name[1] = 30
/body[1]/book[1]/name[1]@atr = 10
/body[1]/book[1]/date[1] = 10
/body[1]/book[1]/memo[1] = 60
--------------------



----------------------------------------
相対階層情報


☆概要
XMLパスの書式に近い形で、階層情報を定義する。
先頭に「/」を付けなければ、「$BaseStart」定義で指定した階層を基準に階層を指定する。そのため、通常は「$BaseStart」定義とセットで使用することになる。
タグ名の後ろには、必ず配列番号を指定し、複数のタグに対応できるようにする。
タグの属性の場合は「@」の後に、属性名を指定する。その際、属性に配列番号は指定しない。


☆書式
<タグ名>[<配列番号>]/<タグ名>[<配列番号>] = <バイト数>
<タグ名>[<配列番号>]/<タグ名>[<配列番号>]@<属性名> = <バイト数>


☆備考
配列番号は、[]括弧でくくること。（XMLPathの記述に似せるため）


☆例

例1)
--------------------
$BaseStart, /body[1]/book[1]
    name[1] = 30
    name[1]@atr = 10
    date[1] = 10
    memo[1] = 60
$BaseEnd
--------------------



----------------------------------------
コメント


☆概要
階層に関する説明などを記述する。


☆書式
# [コメント]


☆備考




----------------------------------------



-----------------------------------------------------------------------------
2004年1月 日医標準レセプトソフト開発チーム制作
